# -- Global command arguments to be passed to all traefik's pods
globalArguments:
  - "--global.checknewversion=false"
  - "--global.sendanonymoususage=false"


# -- Additional arguments to be passed at Traefik's binary
# See [CLI Reference](https://docs.traefik.io/reference/static-configuration/cli/)
# Use curly braces to pass values: `helm install --set="additionalArguments={--providers.kubernetesingress.ingressclass=traefik-internal,--log.level=DEBUG}"`
additionalArguments:
  - "--serversTransport.insecureSkipVerify=true"
  - "--log.level=INFO"


deployment:
  enabled: true
  kind: DaemonSet
  replicas: 1
  shareProcessNamespace: false
  dnsPolicy: ""
  dnsConfig: {}

# -- [Pod Disruption Budget](https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-disruption-budget-v1/)
podDisruptionBudget:  # @schema additionalProperties: false
  enabled: false
  maxUnavailable:  # @schema type:[string, integer, null];minimum:0
  minAvailable:    # @schema type:[string, integer, null];minimum:0


ports:
  #  web:
  #    redirectTo: websecure
  websecure:
    tls:
      enabled: true

# -- Create a default IngressClass for Traefik
ingressClass:  # @schema additionalProperties: false
  enabled: true
  isDefaultClass: false
  name: "traefik-external"

# Traefik experimental features
experimental:
  # -- Enable traefik experimental plugins
  plugins: {}
  # demo:
  #   moduleName: github.com/traefik/plugindemo
  #   version: v0.2.1
  kubernetesGateway:
    # -- Enable traefik experimental GatewayClass CRD
    enabled: false

gateway:
  # -- When providers.kubernetesGateway.enabled, deploy a default gateway
  enabled: true
  listeners:
    web:
      # -- Port is the network port. Multiple listeners may use the same port, subject to the Listener compatibility rules.
      # The port must match a port declared in ports section.
      port: 8000
    # websecure listener is disabled by default because certificateRefs needs to be added,
    # or you may specify TLS protocol with Passthrough mode and add "--providers.kubernetesGateway.experimentalChannel=true" in additionalArguments section.
    # websecure:
    #   # -- Port is the network port. Multiple listeners may use the same port, subject to the Listener compatibility rules.
    #   # The port must match a port declared in ports section.
    #   port: 8443
    #   # -- Optional hostname. See [Hostname](https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.Hostname)
    #   hostname:
    #   # Specify expected protocol on this listener See [ProtocolType](https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.ProtocolType)
    #   protocol: HTTPS
    #   # -- Routes are restricted to namespace of the gateway [by default](https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.FromNamespaces)
    #   namespacePolicy:
    #   # -- Add certificates for TLS or HTTPS protocols. See [GatewayTLSConfig](https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io%2fv1.GatewayTLSConfig)
    #   certificateRefs:
    #   # -- TLS behavior for the TLS session initiated by the client. See [TLSModeType](https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.TLSModeType).
    #   mode:

gatewayClass:  # @schema additionalProperties: false
  # -- When providers.kubernetesGateway.enabled and gateway.enabled, deploy a default gatewayClass
  enabled: true
  # -- Set a custom name to GatewayClass
  name: ""
  # -- Additional gatewayClass labels (e.g. for filtering gateway objects by custom labels)
  labels: {}

ingressRoute:
  dashboard:
    # -- Create an IngressRoute for the dashboard
    enabled: false
    # -- TLS options (e.g. secret containing certificate)
    tls: {}
  healthcheck:
    enabled: false
    tls: {}

providers:  # @schema additionalProperties: false
  kubernetesCRD:
    # -- Load Kubernetes IngressRoute provider
    enabled: true
    # -- When the parameter is set, only resources containing an annotation with the same value are processed. Otherwise, resources missing the annotation, having an empty value, or the value traefik are processed. It will also set required annotation on Dashboard and Healthcheck IngressRoute when enabled.
    ingressClass: "traefik-external"

  kubernetesIngress:
    enabled: true

  kubernetesGateway:
    # -- Enable Traefik Gateway provider for Gateway API
    enabled: false
    # -- Toggles support for the Experimental Channel resources (Gateway API release channels documentation).
    # This option currently enables support for TCPRoute and TLSRoute.
    experimentalChannel: false
    # -- Array of namespaces to watch. If left empty, Traefik watches all namespaces.
    namespaces: []
    # -- A label selector can be defined to filter on specific GatewayClass objects only.
    labelselector: ""



service:
  enabled: true
  type: LoadBalancer
  # -- Additional annotations applied to both TCP and UDP services (e.g. for cloud provider specific config)
  annotations: {}
  # -- Additional annotations for TCP service only
  annotationsTCP: {}
  # -- Additional annotations for UDP service only
  annotationsUDP: {}
  # -- Additional service labels (e.g. for filtering Service by custom labels)
  labels: {}
  spec:
    loadBalancerIP: "192.168.1.200"
  loadBalancerSourceRanges: []
  # - 192.168.0.1/32
  # - 172.16.0.0/16
  ## -- Class of the load balancer implementation
  # loadBalancerClass: service.k8s.aws/nlb
  externalIPs: []
  # - 1.2.3.4
  ## One of SingleStack, PreferDualStack, or RequireDualStack.
  # ipFamilyPolicy: SingleStack
  ## List of IP families (e.g. IPv4 and/or IPv6).
  ## ref: https://kubernetes.io/docs/concepts/services-networking/dual-stack/#services
  # ipFamilies:
  #   - IPv4
  #   - IPv6
  ##
  additionalServices: {}
  ## -- An additional and optional internal Service.
  ## Same parameters as external Service
  # internal:
  #   type: ClusterIP
  #   # labels: {}
  #   # annotations: {}
  #   # spec: {}
  #   # loadBalancerSourceRanges: []
  #   # externalIPs: []
  #   # ipFamilies: [ "IPv4","IPv6" ]


volumes: []
# - name: public-cert
#   mountPath: "/certs"
#   type: secret
# - name: '{{ printf "%s-configs" .Release.Name }}'
#   mountPath: "/config"
#   type: configMap

# -- Additional volumeMounts to add to the Traefik container
additionalVolumeMounts: []
# -- For instance when using a logshipper for access logs
# - name: traefik-logs
#   mountPath: /var/log/traefik

metrics:
  ## -- Enable metrics for internal resources. Default: false
  addInternals: false

  ## -- Prometheus is enabled by default.
  ## -- It can be disabled by setting "prometheus: null"
  prometheus:
    # -- Entry point used to expose metrics.
    entryPoint: metrics
    ## Enable metrics on entry points. Default: true
    addEntryPointsLabels:  # @schema type:[boolean, null]
    ## Enable metrics on routers. Default: false
    addRoutersLabels:  # @schema type:[boolean, null]
    ## Enable metrics on services. Default: true
    addServicesLabels:  # @schema type:[boolean, null]
    ## Buckets for latency metrics. Default="0.1,0.3,1.2,5.0"
    buckets: ""
    ## When manualRouting is true, it disables the default internal router in
    ## order to allow creating a custom router for prometheus@internal service.
    manualRouting: false
    service:
      # -- Create a dedicated metrics service to use with ServiceMonitor
      enabled: false
      labels: {}
      annotations: {}
    # -- When set to true, it won't check if Prometheus Operator CRDs are deployed
    disableAPICheck:  # @schema type:[boolean, null]
    serviceMonitor:
      # -- Enable optional CR for Prometheus Operator. See EXAMPLES.md for more details.
      enabled: false
      metricRelabelings: []
      relabelings: []
      jobLabel: ""
      interval: ""
      honorLabels: false
      scrapeTimeout: ""
      honorTimestamps: false
      enableHttp2: false
      followRedirects: false
      additionalLabels: {}
      namespace: ""
      namespaceSelector: {}
    prometheusRule:
      # -- Enable optional CR for Prometheus Operator. See EXAMPLES.md for more details.
      enabled: false
      additionalLabels: {}
      namespace: ""

  #  influxdb2:
  #    ## Address instructs exporter to send metrics to influxdb v2 at this address.
  #    address: localhost:8086
  #    ## Token with which to connect to InfluxDB v2.
  #    token: xxx
  #    ## Organisation where metrics will be stored.
  #    org: ""
  #    ## Bucket where metrics will be stored.
  #    bucket: ""
  #    ## The interval used by the exporter to push metrics to influxdb. Default=10s
  #    # pushInterval: 30s
  #    ## Additional labels (influxdb tags) on all metrics.
  #    # additionalLabels:
  #    #   env: production
  #    #   foo: bar
  #    ## Enable metrics on entry points. Default=true
  #    # addEntryPointsLabels: false
  #    ## Enable metrics on routers. Default=false
  #    # addRoutersLabels: true
  #    ## Enable metrics on services. Default=true
  #    # addServicesLabels: false
  #  statsd:
  #    ## Address instructs exporter to send metrics to statsd at this address.
  #    address: localhost:8125
  #    ## The interval used by the exporter to push metrics to influxdb. Default=10s
  #    # pushInterval: 30s
  #    ## The prefix to use for metrics collection. Default="traefik"
  #    # prefix: traefik
  #    ## Enable metrics on entry points. Default=true
  #    # addEntryPointsLabels: false
  #    ## Enable metrics on routers. Default=false
  #    # addRoutersLabels: true
  #    ## Enable metrics on services. Default=true
  #    # addServicesLabels: false
  otlp:
    # -- Set to true in order to enable the OpenTelemetry metrics
    enabled: false
    # -- Enable metrics on entry points. Default: true
    addEntryPointsLabels:  # @schema type:[boolean, null]
    # -- Enable metrics on routers. Default: false
    addRoutersLabels:  # @schema type:[boolean, null]
    # -- Enable metrics on services. Default: true
    addServicesLabels:  # @schema type:[boolean, null]
    # -- Explicit boundaries for Histogram data points. Default: [.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10]
    explicitBoundaries: []
    # -- Interval at which metrics are sent to the OpenTelemetry Collector. Default: 10s
    pushInterval: ""
    http:
      # -- Set to true in order to send metrics to the OpenTelemetry Collector using HTTP.
      enabled: false
      # -- Format: <scheme>://<host>:<port><path>. Default: http://localhost:4318/v1/metrics
      endpoint: ""
      # -- Additional headers sent with metrics by the reporter to the OpenTelemetry Collector.
      headers: {}
      ## Defines the TLS configuration used by the reporter to send metrics to the OpenTelemetry Collector.
      tls:
        # -- The path to the certificate authority, it defaults to the system bundle.
        ca: ""
        # -- The path to the public certificate. When using this option, setting the key option is required.
        cert: ""
        # -- The path to the private key. When using this option, setting the cert option is required.
        key: ""
        # -- When set to true, the TLS connection accepts any certificate presented by the server regardless of the hostnames it covers.
        insecureSkipVerify:  # @schema type:[boolean, null]
    grpc:
      # -- Set to true in order to send metrics to the OpenTelemetry Collector using gRPC
      enabled: false
      # -- Format: <scheme>://<host>:<port><path>. Default: http://localhost:4318/v1/metrics
      endpoint: ""
      # -- Allows reporter to send metrics to the OpenTelemetry Collector without using a secured protocol.
      insecure: false
      ## Defines the TLS configuration used by the reporter to send metrics to the OpenTelemetry Collector.
      tls:
        # -- The path to the certificate authority, it defaults to the system bundle.
        ca: ""
        # -- The path to the public certificate. When using this option, setting the key option is required.
        cert: ""
        # -- The path to the private key. When using this option, setting the cert option is required.
        key: ""
        # -- When set to true, the TLS connection accepts any certificate presented by the server regardless of the hostnames it covers.
        insecureSkipVerify: false

## Tracing
# -- https://doc.traefik.io/traefik/observability/tracing/overview/
tracing:  # @schema additionalProperties: false
  # -- Enables tracing for internal resources. Default: false.
  addInternals: false
  otlp:
    # -- See https://doc.traefik.io/traefik/v3.0/observability/tracing/opentelemetry/
    enabled: false
    http:
      # -- Set to true in order to send metrics to the OpenTelemetry Collector using HTTP.
      enabled: false
      # -- Format: <scheme>://<host>:<port><path>. Default: http://localhost:4318/v1/metrics
      endpoint: ""
      # -- Additional headers sent with metrics by the reporter to the OpenTelemetry Collector.
      headers: {}
      ## Defines the TLS configuration used by the reporter to send metrics to the OpenTelemetry Collector.
      tls:
        # -- The path to the certificate authority, it defaults to the system bundle.
        ca: ""
        # -- The path to the public certificate. When using this option, setting the key option is required.
        cert: ""
        # -- The path to the private key. When using this option, setting the cert option is required.
        key: ""
        # -- When set to true, the TLS connection accepts any certificate presented by the server regardless of the hostnames it covers.
        insecureSkipVerify: false
    grpc:
      # -- Set to true in order to send metrics to the OpenTelemetry Collector using gRPC
      enabled: false
      # -- Format: <scheme>://<host>:<port><path>. Default: http://localhost:4318/v1/metrics
      endpoint: ""
      # -- Allows reporter to send metrics to the OpenTelemetry Collector without using a secured protocol.
      insecure: false
      ## Defines the TLS configuration used by the reporter to send metrics to the OpenTelemetry Collector.
      tls:
        # -- The path to the certificate authority, it defaults to the system bundle.
        ca: ""
        # -- The path to the public certificate. When using this option, setting the key option is required.
        cert: ""
        # -- The path to the private key. When using this option, setting the cert option is required.
        key: ""
        # -- When set to true, the TLS connection accepts any certificate presented by the server regardless of the hostnames it covers.
        insecureSkipVerify: false


autoscaling:
  # -- Create HorizontalPodAutoscaler object.
  # See EXAMPLES.md for more details.
  enabled: false

persistence:
  # -- Enable persistence using Persistent Volume Claims
  # ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
  # It can be used to store TLS certificates, see `storage` in certResolvers
  enabled: false
  name: data
  existingClaim: ""
  accessMode: ReadWriteOnce
  size: 128Mi
  storageClass: ""
  volumeName: ""
  path: /data
  annotations: {}
  # -- Only mount a subpath of the Volume into the pod
  subPath: ""

# -- Certificates resolvers configuration.
# Ref: https://doc.traefik.io/traefik/https/acme/#certificate-resolvers
# See EXAMPLES.md for more details.
certResolvers: {}

# -- Whether Role Based Access Control objects like roles and rolebindings should be created
rbac:  # @schema additionalProperties: false
  enabled: true


# -- This example pod anti-affinity forces the scheduler to put traefik pods
# -- on nodes where no other traefik pods are scheduled.
# It should be used when hostNetwork: true to prevent port conflicts
affinity: {}
#  podAntiAffinity:
#    requiredDuringSchedulingIgnoredDuringExecution:
#      - labelSelector:
#          matchLabels:
#            app.kubernetes.io/name: '{{ template "traefik.name" . }}'
#            app.kubernetes.io/instance: '{{ .Release.Name }}-{{ .Release.Namespace }}'
#        topologyKey: kubernetes.io/hostname

# -- nodeSelector is the simplest recommended form of node selection constraint.
nodeSelector: {}
# -- Tolerations allow the scheduler to schedule pods with matching taints.
tolerations: []
# -- You can use topology spread constraints to control
# how Pods are spread across your cluster among failure-domains.
topologySpreadConstraints: []
# This example topologySpreadConstraints forces the scheduler to put traefik pods
# on nodes where no other traefik pods are scheduled.
#  - labelSelector:
#      matchLabels:
#        app.kubernetes.io/name: '{{ template "traefik.name" . }}'
#    maxSkew: 1
#    topologyKey: kubernetes.io/hostname
#    whenUnsatisfiable: DoNotSchedule

# -- This field override the default Release Namespace for Helm.
# It will not affect optional CRDs such as `ServiceMonitor` and `PrometheusRules`
namespaceOverride: "traefik-system"

